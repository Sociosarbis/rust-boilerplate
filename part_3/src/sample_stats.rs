use super::*;

use std::cmp::Ordering;

impl Solution {
  pub fn sample_stats(count: Vec<i32>) -> Vec<f64> {
    let mut ret = vec![0.0; 5];
    for (i, &c) in count.iter().enumerate() {
      if c != 0 {
        ret[0] = i as f64;
        break;
      }
    }
    for (i, &c) in count.iter().enumerate().rev() {
      if c != 0 {
        ret[1] = i as f64;
        break;
      }
    }
    let mut temp = 0;
    let mut acc = 0;
    for (i, &c) in count.iter().enumerate() {
      if c > temp {
        ret[4] = i as f64;
        temp = c;
      }
      if c != 0 {
        acc += c;
      }
    }
    temp = 0;
    for (i, &c) in count.iter().enumerate() {
      if c != 0 {
        temp += c;
        match temp.cmp(&(acc / 2)) {
          Ordering::Equal => {
            if acc % 2 == 0 {
              ret[3] = i as f64;
            }
          }
          Ordering::Greater => {
            if ret[3] != 0.0 {
              ret[3] = (ret[3] + i as f64) / 2.0;
            } else {
              ret[3] = i as f64;
            }
            break;
          }
          _ => {}
        }
      }
    }
    for (i, c) in count.into_iter().enumerate() {
      if c != 0 {
        ret[2] += (c as f64 / acc as f64) * i as f64;
      }
    }
    ret
  }
}

#[cfg(test)]
mod tests {
  use std::vec;

  use super::*;

  struct Suite {
    count: Vec<i32>,
    ret: Vec<f64>,
  }

  #[test]
  fn test_sample_stats_simple() {
    let suites = vec![
      Suite {
        count: vec![
          0, 1, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ],
        ret: vec![1.00000, 3.00000, 2.37500, 2.50000, 3.00000],
      },
      Suite {
        count: vec![
          0, 4, 3, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ],
        ret: vec![1.00000, 4.00000, 2.1818181818181817, 2.00000, 1.00000],
      },
    ];

    for s in suites {
      assert_eq!(s.ret, Solution::sample_stats(s.count));
    }
  }
}
